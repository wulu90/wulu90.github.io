# 信号槽
信号槽用作对象之间的通信，是Qt重要的也是区别与其他框架的特性，元对象系统实现了信号槽。

## Introduction
在GUI编程中，当我们改变了一个部件，通常我们希望其他部件被通知到。推而广之，我们希望任何种类的对象都能与其他对象通信，例如，当点击一个关闭按钮，通常希望窗口的 close() 函数被调用。

其他工具实现这种通信用的是回调，回调是一个指向函数的指针，当你需要一个处理函数来通知一些事件时，向处理函数传递一个指针，指向其他函数（这就是callback），在适当的时候，处理函数会调用回调。回调不够直观，且在保证回调参数的类型正确性上会遇到麻烦。、

## Signals & Slots
在Qt中，当特定事件发生后，发送一个Signal。Qt的部件有许多预定义信号，但可以继承部件类添加信号，Slot是响应特定信号的函数。Qt部件有许多预定义的槽，但是通常的实践是继承部件类添加槽来处理感兴趣的信号。

![abstract-connections](abstract-connections.png)

信号槽机制是类型安全的。signal的签名必须与接收它的slot的签名匹配。（实际上，slot的签名可以比它接收到的signal的签名短，因为可以忽略多余的参数。）由于签名是兼容的，当使用基于函数指针的语法，编译器可以帮我们检测类型错配。基于字符串的SIGNAL-SLOT语法会在运行时检测类型不匹配。信号与槽是松散耦合的：一个发出信号的类不知道也不关心哪个槽会接收信号。Qt信号槽机制可以保证的是，当一个信号连接到一个槽，槽会在正确的时间被调用，同时传入信号的参数。信号槽可以用任意数量任意类型的参数。信号槽是类型安全的。

所有派生自QObject或其子类的类都可以包含信号和槽。当对象用某种方式改变了状态，且可能对其他对象感兴趣时，（且可能有其他对象感兴趣），会发出信号。这就是对象通信的全部内容。不知道也不关心是否有其他对象接收它发出的信号。这就是信息封装，保证了对象可以用作软件组件。

Slots槽可以用来接收信号，但它们也同样是普通的成员函数。就像对象不知道是否有其他对象接收它的信号，一个slot也不知道是否有信号连接到它。这保证的Qt可以创建真正独立的组件。

**可以连接任意多的信号到一个槽，一个信号可以连接到任意多的槽，甚至一个信号可以直接连接到另一个信号，当第一个信号发出后，第二个信号会立即发出。**

综上，信号槽构建了一个强大的组件编程机制。

## Signals
当对象的内部状态在某种情况下发生了改变，且该对象的客户或所有者可能对这种改变有兴趣时，对象发出了Signal。Signals是公开可访问函数且可以在任何地方被发出，但推荐的做法是只在定义了该信号的类和其子类中发出。

当一个Signal发出时，它连接到的Slots通常会立即执行，就像一个普通的函数调用。在此情况下，信号槽机制是完全独立于任何GUI事件循环的。**emit语句之后的代码会在所有Slots都返回后执行。**当使用*quened connections*时情况略有不同，emit关键字后面的语句会立即执行，Slots则会稍后执行。

一个Signal连接到多个Slots的情况下，当这个Signal发出时，，Slots会按照连接的先后顺序一个接一个的被执行。

Signals由moc自动生成，一定不能在 .cpp 文件中实现。它们永远不能有返回值。

关于参数需要注意一点：经验表明信号槽在没有使用特殊类型时经常复用。当 QScrollBar::valueChanged() 使用了特殊类型的参数，假设是 QScrollBar::Range ，那么就只能连接到为 QScrollBar 专门设计的Slots。连接到其他输入部件就不可能了。

## Slots
当Slot连接的Signal发出时，它被调用。Slots都是普通的C++函数，可以被正常调用，唯一的不同是信号可以连接到它们。

由于Slots是普通的成员函数，它们被直接调用时遵循普通的C++规则。当通过 signal-slot 连接时，slots可以被任何组件调用，且忽略访问级别。这意味着，任意类的实例中发出的信号，可能导致一个无关类的实例中，一个私有slot被调用。

可以定义slot为虚函数，实践中发现这很有用。

相对于回调callback，signals和slots由于提供了这些额外的灵活性，会稍微慢一些，但在实际应用程序中，这个区别是微不足道的。一般来说，发出一个连接到一些slot的signal，大约会比直接通过非虚函数调用来调用接收者慢十倍。这些开销是用来定位连接对象，安全的遍历所有连接，检查随后的连接在信号发出期间没有被销毁，编组参数的。十个非虚函数调用听起来很多，但不及任何 new
 和 delete 操作的开销大，例如，当一个字符串、数组或链表的操作背后需要 new 或 delete时，信号槽的开销只占整个函数调用花费的一小部分。在slot中有一个系统调用，或者间接调用了超过十个函数也是一样。信号槽机制的简洁和灵活是非常值得这些开销的，尤其是用户甚至不会察觉到。

 需要注意的是，其他库中定义了叫做 signals 或 slots 的变量，在和Qt一起编译时，有可能导致编译警告或错误。要解决这个问题，*#undef*那些有冲突的预处理符号。
